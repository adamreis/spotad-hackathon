<!doctype html>
<html>
    <head>
        <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js" type="text/javascript"></script>
        <script src="http://underscorejs.org/underscore.js"></script>
        <script type="text/javascript">
$(document).ready(function(){
    //Canvas stuff
    var canvas = $("canvas")[0];
    var ctx = canvas.getContext("2d");
    var object_colors = {0:"red", 1:"blue"};
    var width, height, road_width, object_width;
    var car_prop = 0.85;

    // game state
    // obstacles and states have the same structure:
    // {
    //     column: an interger 0 or 1 indicating which track it's on
    //     y_proportion: a float in [0, 1] indicating the y position of the object.  0 is the top.
    // }
    // car_columns is an array of 2 floats in [0, 1], where 0 represents being in the left track and 1 represents being in the right track.
    // speed is in units of screens per second
    var obstacles, targets, car_columns, speed, min_distance_between_objects, obstacles_per_second, targets_per_second, loop, collision, accel;

    var update_ms = 16;

    function init() {
        obstacles = [];
        targets = [];
        car_columns = [0, 1];
        speed = 0.4;
        collision = false;
        accel = 0.01
        min_distance_between_objects = 0.3;
        objects_per_second = 0.8;
        generate_object(0);
        generate_object(1);

        if (typeof loop === "undefined") {
            clearInterval(loop);
        }
        loop = setInterval(function() {update(); render();}, update_ms);
    }

    function generate_object(track) {
        var obj = {
            track: track,
            column: Math.floor(Math.random() * 2),
            y_proportion: -(Math.random() * 2 * (speed / objects_per_second - min_distance_between_objects) + min_distance_between_objects)
        };
        if (Math.floor(Math.random() * 2)) {
            obstacles.push(obj);
        } else {
            targets.push(obj);
        }
    }

    function update_y_proportion(obj) {
        obj.y_proportion += speed * update_ms / 1000;
    }

    function update() {
        var min_y = [Infinity, Infinity];
        _.each(obstacles, function(obstacle) {
            update_y_proportion(obstacle);
            min_y[obstacle.track] = Math.min(min_y[obstacle.track], obstacle.y_proportion);
        });
        _.each(targets, function(target) {
            update_y_proportion(target);
            min_y[target.track] = Math.min(min_y[target.track], target.y_proportion);
        });
        if (min_y[0] > 0) {
            generate_object(0);
        }
        if (min_y[1] > 0) {
            generate_object(1);
        }

        collision = false;
        _.each(obstacles, function(obstacle) {
            var car_x = car_columns[obstacle.track] * width / 4;
            var car_y = car_prop * height;
            var obstacle_x = obstacle.column * width / 4;
            var obstacle_y = obstacle.y_proportion * height;

            var d = distance(car_x, car_y, obstacle_x, obstacle_y) 
            if ( d < object_width/2){
                collision = true;
            }
        });

        targets = _.filter(targets, function(target) {
            var car_x = car_columns[target.track] * width / 4;
            var car_y = car_prop * height;
            var target_x = target.column * width / 4;
            var target_y = target.y_proportion * height;

            var d = distance(car_x, car_y, target_x, target_y) 
            if ( d < object_width/2 - 5){
                return false;
                // console.log('hit target!')
            }
            return true;
        });

        _.each(targets, function(target) {

            var target_y = target.y_proportion * height;

            if (height - target_y <= object_width/2) {
                collision = true;
            }
        });


        speed += accel * update_ms / 1000;
    }

    function render()
    {
        width = canvas.width;
        height = canvas.height;
        if (height < width) {
            width = height;
        }
        road_width = width/2;
        object_width = 10/48 * road_width;
        // background
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, width, height);

        _.each(obstacles, function(obstacle) {
            render_obstacle(obstacle.track, obstacle.column, obstacle.y_proportion);
        });
        _.each(targets, function(target) {
            render_target(target.track, target.column, target.y_proportion);
        });

        render_cars();

        // frame
        ctx.strokeStyle = "black";
        ctx.strokeRect(0, 0, width, height);
        ctx.strokeRect(width/2, 0, 0, height);

        if (collision) {
            clearInterval(loop);
        }
    }

    // render_obstacle(0/1, 0/1, 0-1, 'blue')
    function render_obstacle(track, column, y_proportion) {
        x = x_val_for_track_and_column(track, column);
        y = height * y_proportion - object_width / 2;

        // outer rectangle
        ctx.fillStyle = object_colors[track];
        roundRect(ctx, x, y, object_width, object_width, object_width / 4, true, false);


        // inner rectangle
        x += object_width / 4;
        y += object_width / 4;
        ctx.strokeStyle = "white";
        ctx.lineWidth = 5;
        roundRect(ctx, x, y, object_width/2, object_width/2, object_width/16, false, true)

    }
    function render_target(track, column, y_proportion) {
        x = x_val_for_track_and_column(track, column);
        x += object_width / 2;
        y = height * y_proportion;

        // outer circle
        ctx.beginPath();
        ctx.fillStyle = object_colors[track];
        ctx.arc(x, y, object_width/2, 0, 2 * Math.PI);
        ctx.fill();

        // inner circle
        ctx.beginPath()
        ctx.strokeStyle = "white";
        ctx.lineWidth = 5;
        ctx.arc(x, y, object_width/4, 0, 2 * Math.PI);
        ctx.stroke();
    }
    function render_cars() {
        render_car(0, car_columns[0], 1);
        render_car(1, car_columns[1], 1);
    }

    function render_car(track, column, heading) {
        x = x_val_for_track_and_column(track, column);
        y = car_prop * height;

        ctx.fillStyle = object_colors[track];
        ctx.fillRect(x, y, object_width, object_width*1.7);
    }

    function x_val_for_track_and_column(track, column) {
        return track * road_width + column * road_width/2 + 7/24 * road_width/2;
    }

    $(canvas).click(function(e) {
        var i;
        if (e.offsetX < road_width) {
            i = 0;
        } else if (e.offsetX < 2 * road_width) {
            i = 1;
        } else {
            return;
        }
        if (car_columns[i]) {
            car_columns[i] = 0;
        } else {
            car_columns[i] = 1;
        }
    });
    $(document).keydown(function(e) {
        var i;
        if (_.contains([37, 70], e.which)) {
            i = 0;
        } else if (_.contains([39, 74], e.which)) {
            i = 1;
        } else {
            return;
        }

        if (car_columns[i]) {
            car_columns[i] = 0;
        } else {
            car_columns[i] = 1;
        }
    });

    init();

    /**
     * Draws a rounded rectangle using the current state of the canvas.
     * If you omit the last three params, it will draw a rectangle
     * outline with a 5 pixel border radius
     * @param {CanvasRenderingContext2D} ctx
     * @param {Number} x The top left x coordinate
     * @param {Number} y The top left y coordinate
     * @param {Number} width The width of the rectangle
     * @param {Number} height The height of the rectangle
     * @param {Number} radius The corner radius. Defaults to 5;
     * @param {Boolean} fill Whether to fill the rectangle. Defaults to false.
     * @param {Boolean} stroke Whether to stroke the rectangle. Defaults to true.
     */
    function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
      if (typeof stroke == "undefined" ) {
        stroke = true;
      }
      if (typeof radius === "undefined") {
        radius = 5;
      }
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
      if (stroke) {
        ctx.stroke();
      }
      if (fill) {
        ctx.fill();
      }
    }

    function distance(x1, y1, x2, y2) {
        return Math.sqrt(Math.pow(x1-x2, 2) + Math.pow(y1-y2, 2));
    }
});
        </script>
        <style type="text/css">
html, body, canvas {
    margin: 0;
    padding: 0;
}
        </style>
    </head>
    <body>
        <canvas width="400%" height="550%"></canvas>
    </body>
</html>
