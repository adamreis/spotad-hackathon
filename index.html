<!doctype html>
<html>
    <head>
        <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js" type="text/javascript"></script>
        <script src="http://underscorejs.org/underscore.js"></script>
        <script type="text/javascript">
$(document).ready(function(){
    //Canvas stuff
    var canvas = $("canvas")[0];
    var ctx = canvas.getContext("2d");
    var object_colors = {0:"red", 1:"blue"};
    var width, height, road_width, object_width;

    // game state
    // obstacles and states have the same structure:
    // {
    //     column: an interger 0 or 1 indicating which track it's on
    //     y_proportion: a float in [0, 1] indicating the y position of the object.  0 is the top.
    // }
    // car_columns is an array of 2 floats in [0, 1], where 0 represents being in the left track and 1 represents being in the right track.
    // speed is in units of screens per second
    var obstacles, targets, car_columns, speed, min_distance_between_objects, obstacles_per_second, targets_per_second;

    var update_ms = 16;

    function init() {
        obstacles = [];
        targets = [];
        car_columns = [0, 1];
        speed = 0.4;
        min_distance_between_objects = 0.1;
        generate_object();
        var loop;
        if (typeof loop === "undefined") {
            clearInterval(loop);
        }
        loop = setInterval(function() {update(); render();}, update_ms);
    }

    function generate_object() {
        var obj = {
            track: Math.floor(Math.random() * 2),
            column: Math.floor(Math.random() * 2),
            y_proportion: 0
        };
        if (Math.floor(Math.random() * 2)) {
            obstacles.push(obj);
        } else {
            targets.push(obj);
        }
    }

    function update_y_proportion(obj) {
        obj.y_proportion += speed * update_ms / 1000;
    }

    function update() {
        var min_y = Infinity;
        _.each(obstacles, function(obstacle) {
            update_y_proportion(obstacle);
            min_y = Math.min(min_y, obstacle.y_proportion);
        });
        _.each(targets, function(target) {
            update_y_proportion(target);
            min_y = Math.min(min_y, target.y_proportion);
        });
        if (min_y > 0.5) {
            generate_object();
        }
    }

    function render()
    {
        width = canvas.width;
        height = canvas.height;
        if (height < width) {
            width = height;
        }
        road_width = width/2;
        object_width = 10/48 * road_width;
        // background
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, width, height);

        _.each(obstacles, function(obstacle) {
            render_obstacle(obstacle.track, obstacle.column, obstacle.y_proportion);
        });
        _.each(targets, function(target) {
            render_target(target.track, target.column, target.y_proportion);
        });

        render_cars();

        // frame
        ctx.strokeStyle = "black";
        ctx.strokeRect(0, 0, width, height);
        ctx.strokeRect(width/2, 0, 0, height);

    }

    // render_obstacle(0/1, 0/1, 0-1, 'blue')
    function render_obstacle(track, column, y_proportion) {
        x = x_val_for_track_and_column(track, column);
        y = height * y_proportion - object_width / 2;

        // outer rectangle
        ctx.fillStyle = object_colors[track];
        roundRect(ctx, x, y, object_width, object_width, object_width / 4, true, false);


        // inner rectangle
        x += object_width / 4;
        y += object_width / 4;
        ctx.strokeStyle = "white";
        ctx.lineWidth = 5;
        roundRect(ctx, x, y, object_width/2, object_width/2, object_width/16, false, true)

    }
    function render_target(track, column, y_proportion) {
        x = x_val_for_track_and_column(track, column);
        x += object_width / 2;
        y = height * y_proportion;

        // outer circle
        ctx.beginPath();
        ctx.fillStyle = object_colors[track];
        ctx.arc(x, y, object_width/2, 0, 2 * Math.PI);
        ctx.fill();

        // inner circle
        ctx.beginPath()
        ctx.strokeStyle = "white";
        ctx.lineWidth = 5;
        ctx.arc(x, y, object_width/4, 0, 2 * Math.PI);
        ctx.stroke();
    }
    function render_cars() {
        render_car(0, car_columns[0], 1);
        render_car(1, car_columns[1], 1);
    }

    function render_car(track, column, heading) {
        x = x_val_for_track_and_column(track, column);
        y = .85 * height;

        ctx.fillStyle = object_colors[track];
        ctx.fillRect(x, y, object_width, object_width*1.7);
    }

    function x_val_for_track_and_column(track, column) {
        return track * road_width + column * road_width/2 + 7/24 * road_width/2;
    }

    $(canvas).click(function(e) {
        var i;
        if (e.offsetX < road_width) {
            i = 0;
        } else if (e.offsetX < 2 * road_width) {
            i = 1;
        } else {
            return;
        }
        if (car_columns[i]) {
            car_columns[i] = 0;
        } else {
            car_columns[i] = 1;
        }
    });
    $(document).keydown(function(e) {
        var i;
        if (_.contains([37, 70], e.which)) {
            i = 0;
        } else if (_.contains([39, 74], e.which)) {
            i = 1;
        } else {
            return;
        }

        if (car_columns[i]) {
            car_columns[i] = 0;
        } else {
            car_columns[i] = 1;
        }
    });

    init();

    /**
     * Draws a rounded rectangle using the current state of the canvas.
     * If you omit the last three params, it will draw a rectangle
     * outline with a 5 pixel border radius
     * @param {CanvasRenderingContext2D} ctx
     * @param {Number} x The top left x coordinate
     * @param {Number} y The top left y coordinate
     * @param {Number} width The width of the rectangle
     * @param {Number} height The height of the rectangle
     * @param {Number} radius The corner radius. Defaults to 5;
     * @param {Boolean} fill Whether to fill the rectangle. Defaults to false.
     * @param {Boolean} stroke Whether to stroke the rectangle. Defaults to true.
     */
    function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
      if (typeof stroke == "undefined" ) {
        stroke = true;
      }
      if (typeof radius === "undefined") {
        radius = 5;
      }
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
      if (stroke) {
        ctx.stroke();
      }
      if (fill) {
        ctx.fill();
      }
    }
});
        </script>
        <style type="text/css">
html, body, canvas {
    margin: 0;
    padding: 0;
}
        </style>
    </head>
    <body>
        <canvas width="400%" height="550%"></canvas>
    </body>
</html>
